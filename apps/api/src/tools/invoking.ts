/**
 * Invoking stage tool handlers
 *
 * Implements the tool handlers for the Invoking stage:
 * - set_spark: Captures the user's adventure vision
 * - signal_ready: Signals the stage is ready for advancement
 *
 * These handlers are registered with the tool dispatcher and called
 * when Claude invokes the corresponding tools during conversation.
 */

import { registerToolHandler } from '../services/tool-dispatcher.js';
import type { ToolContext } from '../services/tool-dispatcher.js';
import { getSupabase } from '../services/supabase.js';
import type { SageEvent } from '@sage-codex/shared-types';

// =============================================================================
// Types
// =============================================================================

interface SetSparkInput {
  name: string;
  vision: string;
}

interface SignalReadyInput {
  stage: string;
  summary: string;
}

// =============================================================================
// Event Builders
// =============================================================================

/**
 * Build a panel:spark SSE event from the tool input.
 */
function buildSparkEvent(input: SetSparkInput): SageEvent {
  return {
    type: 'panel:spark',
    data: {
      name: input.name,
      vision: input.vision,
    },
  };
}

/**
 * Build a ui:ready SSE event from the tool input.
 */
function buildReadyEvent(input: SignalReadyInput): SageEvent {
  return {
    type: 'ui:ready',
    data: {
      stage: input.stage,
      summary: input.summary,
    },
  };
}

// =============================================================================
// Pending Events Queue
// =============================================================================

/**
 * Events generated by tool handlers that need to be sent to the client.
 *
 * The chat route collects these after tool dispatch and sends them as SSE.
 * This avoids coupling the tool handler to the response object.
 */
let pendingEvents: SageEvent[] = [];

/**
 * Get and clear all pending events from tool handlers.
 */
export function drainPendingEvents(): SageEvent[] {
  const events = [...pendingEvents];
  pendingEvents = [];
  return events;
}

// =============================================================================
// Tool Handlers
// =============================================================================

/**
 * Register all Invoking stage tool handlers.
 *
 * Called once at server startup to wire up the handlers.
 */
export function registerInvokingTools(): void {
  registerToolHandler('set_spark', handleSetSpark);
  registerToolHandler('signal_ready', handleSignalReady);
}

/**
 * Handle the set_spark tool call.
 *
 * Captures the user's adventure vision and queues a panel:spark
 * event for the frontend to update the SparkPanel.
 */
async function handleSetSpark(
  input: Record<string, unknown>,
  context: ToolContext
): Promise<{ result: unknown; isError: boolean }> {
  const sparkInput = input as unknown as SetSparkInput;

  if (!sparkInput.name || !sparkInput.vision) {
    return {
      result: 'Both name and vision are required for set_spark',
      isError: true,
    };
  }

  // Queue the panel:spark event for the frontend
  pendingEvents.push(buildSparkEvent(sparkInput));

  // Save spark to adventure state in Supabase (best effort)
  try {
    await persistSparkToState(context.sessionId, sparkInput);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error(`Failed to persist spark: ${message}`);
  }

  return {
    result: {
      status: 'spark_captured',
      name: sparkInput.name,
      vision: sparkInput.vision,
    },
    isError: false,
  };
}

/**
 * Handle the signal_ready tool call.
 *
 * Signals that the current stage is complete and the user can advance.
 * Queues a ui:ready event for the frontend.
 */
async function handleSignalReady(
  input: Record<string, unknown>,
  context: ToolContext
): Promise<{ result: unknown; isError: boolean }> {
  const readyInput = input as unknown as SignalReadyInput;

  if (!readyInput.stage) {
    return {
      result: 'stage is required for signal_ready',
      isError: true,
    };
  }

  // Queue the ui:ready event for the frontend
  pendingEvents.push(buildReadyEvent(readyInput));

  // Persist stage summary for cross-stage context (best effort)
  if (readyInput.summary) {
    try {
      await persistStageSummary(
        context.sessionId,
        readyInput.stage,
        readyInput.summary
      );
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      console.warn(`Failed to persist stage summary: ${message}`);
    }
  }

  return {
    result: {
      status: 'ready_signaled',
      stage: readyInput.stage,
      summary: readyInput.summary ?? '',
    },
    isError: false,
  };
}

// =============================================================================
// Persistence
// =============================================================================

/**
 * Persist a stage summary to the adventure state in Supabase.
 *
 * Reads the current state JSONB, merges the summary into
 * `stageSummaries[stage]`, and writes back. Best-effort — failures
 * are logged but don't block the tool call.
 */
async function persistStageSummary(
  sessionId: string,
  stage: string,
  summary: string
): Promise<void> {
  const supabase = getSupabase();

  const { data: stateRow, error: fetchError } = await supabase
    .from('sage_adventure_state')
    .select('id, state')
    .eq('session_id', sessionId)
    .single();

  if (fetchError || !stateRow) {
    console.warn(`Adventure state not found for session ${sessionId}`);
    return;
  }

  const currentState = (stateRow.state as Record<string, unknown>) ?? {};
  const existingSummaries =
    (currentState.stageSummaries as Record<string, string>) ?? {};

  const updatedState = {
    ...currentState,
    stageSummaries: { ...existingSummaries, [stage]: summary },
  };

  const { error: updateError } = await supabase
    .from('sage_adventure_state')
    .update({ state: updatedState })
    .eq('id', stateRow.id);

  if (updateError) {
    console.warn(
      `Failed to persist stage summary for ${stage}: ${updateError.message}`
    );
  }
}

/**
 * Persist the spark data to the adventure state in Supabase.
 *
 * Reads the current state JSONB, merges the spark, and writes back.
 * Scoped to the session via sessionId. Best-effort — failures are
 * logged but don't block the tool call.
 */
async function persistSparkToState(
  sessionId: string,
  spark: SetSparkInput
): Promise<void> {
  const supabase = getSupabase();

  const { data: stateRow, error: fetchError } = await supabase
    .from('sage_adventure_state')
    .select('id, state')
    .eq('session_id', sessionId)
    .single();

  if (fetchError || !stateRow) {
    console.warn(`Adventure state not found for session ${sessionId}`);
    return;
  }

  const currentState = (stateRow.state as Record<string, unknown>) ?? {};
  const updatedState = {
    ...currentState,
    spark: { name: spark.name, vision: spark.vision },
  };

  const { error: updateError } = await supabase
    .from('sage_adventure_state')
    .update({ state: updatedState })
    .eq('id', stateRow.id);

  if (updateError) {
    console.warn(`Failed to update spark state: ${updateError.message}`);
  }
}
