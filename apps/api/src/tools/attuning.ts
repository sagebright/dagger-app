/**
 * Attuning stage tool handlers
 *
 * Implements the tool handler for the Attuning stage:
 * - set_component: Sets a single adventure component value
 *
 * The handler queues a panel:component SSE event so the frontend
 * can update the ComponentSummary panel in real-time.
 */

import { registerToolHandler } from '../services/tool-dispatcher.js';
import type { ToolContext } from '../services/tool-dispatcher.js';
import { getSupabase } from '../services/supabase.js';
import type { SageEvent } from '@sage-codex/shared-types';

// =============================================================================
// Types
// =============================================================================

interface SetComponentInput {
  componentId: string;
  value: string | number | string[];
  confirmed?: boolean;
}

const VALID_COMPONENT_IDS = [
  'span', 'scenes', 'members', 'tier',
  'tenor', 'pillars', 'chorus', 'threads',
];

// =============================================================================
// Event Builders
// =============================================================================

/**
 * Build a panel:component SSE event from the tool input.
 */
function buildComponentEvent(input: SetComponentInput): SageEvent {
  return {
    type: 'panel:component',
    data: {
      componentId: input.componentId,
      value: input.value,
      confirmed: input.confirmed ?? true,
    },
  };
}

// =============================================================================
// Pending Events Queue
// =============================================================================

/**
 * Events generated by attuning tool handlers.
 *
 * The chat route collects these after tool dispatch and sends them as SSE.
 */
let pendingEvents: SageEvent[] = [];

/**
 * Get and clear all pending attuning events.
 */
export function drainAttuningEvents(): SageEvent[] {
  const events = [...pendingEvents];
  pendingEvents = [];
  return events;
}

// =============================================================================
// Tool Handlers
// =============================================================================

/**
 * Register all Attuning stage tool handlers.
 *
 * Called once at server startup to wire up the handlers.
 */
export function registerAttuningTools(): void {
  registerToolHandler('set_component', handleSetComponent);
}

/**
 * Handle the set_component tool call.
 *
 * Validates input, queues a panel:component event, and persists
 * the component selection to the adventure state.
 */
async function handleSetComponent(
  input: Record<string, unknown>,
  context: ToolContext
): Promise<{ result: unknown; isError: boolean }> {
  const componentInput = input as unknown as SetComponentInput;

  if (!isValidSetComponentInput(componentInput)) {
    return {
      result: 'componentId and value are required. Valid IDs: ' +
        VALID_COMPONENT_IDS.join(', '),
      isError: true,
    };
  }

  // Queue the panel:component event for the frontend
  pendingEvents.push(buildComponentEvent(componentInput));

  // Persist to Supabase (best effort)
  try {
    await persistComponentUpdate(context.sessionId, componentInput);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error(`Failed to persist component: ${message}`);
  }

  return {
    result: {
      status: 'component_set',
      componentId: componentInput.componentId,
      value: componentInput.value,
      confirmed: componentInput.confirmed ?? true,
    },
    isError: false,
  };
}

// =============================================================================
// Validation
// =============================================================================

function isValidSetComponentInput(input: SetComponentInput): boolean {
  if (!input.componentId || !VALID_COMPONENT_IDS.includes(input.componentId)) {
    return false;
  }
  if (input.value === undefined || input.value === null) {
    return false;
  }
  return true;
}

// =============================================================================
// Persistence
// =============================================================================

/**
 * Persist the component update to the adventure state in Supabase.
 *
 * Reads the current state JSONB, merges the component, and writes back.
 * Mirrors the same pattern used by the /api/component/select REST route.
 * Best-effort; failures are logged but don't block the tool result.
 */
async function persistComponentUpdate(
  sessionId: string,
  input: SetComponentInput
): Promise<void> {
  const supabase = getSupabase();

  const { data: stateRow, error: fetchError } = await supabase
    .from('sage_adventure_state')
    .select('id, state')
    .eq('session_id', sessionId)
    .single();

  if (fetchError || !stateRow) {
    console.warn(`Adventure state not found for session ${sessionId}`);
    return;
  }

  const currentState = (stateRow.state as Record<string, unknown>) ?? {};
  const components = (currentState.components as Record<string, unknown>) ?? {};

  components[input.componentId] = input.value;

  if (input.confirmed ?? true) {
    const confirmed = new Set(
      (components.confirmedComponents as string[]) ?? []
    );
    confirmed.add(input.componentId);
    components.confirmedComponents = [...confirmed];
  }

  const updatedState = { ...currentState, components };

  const { error: updateError } = await supabase
    .from('sage_adventure_state')
    .update({ state: updatedState })
    .eq('id', stateRow.id);

  if (updateError) {
    console.warn(`Failed to update component state: ${updateError.message}`);
  }
}
