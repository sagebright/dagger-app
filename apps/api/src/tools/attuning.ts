/**
 * Attuning stage tool handlers
 *
 * Implements the tool handler for the Attuning stage:
 * - set_component: Sets a single adventure component value
 *
 * The handler queues a panel:component SSE event so the frontend
 * can update the ComponentSummary panel in real-time.
 */

import { registerToolHandler } from '../services/tool-dispatcher.js';
import { getSupabase } from '../services/supabase.js';
import type { SageEvent } from '@sage-codex/shared-types';

// =============================================================================
// Types
// =============================================================================

interface SetComponentInput {
  componentId: string;
  value: string | number | string[];
  confirmed?: boolean;
}

const VALID_COMPONENT_IDS = [
  'span', 'scenes', 'members', 'tier',
  'tenor', 'pillars', 'chorus', 'threads',
];

// =============================================================================
// Event Builders
// =============================================================================

/**
 * Build a panel:component SSE event from the tool input.
 */
function buildComponentEvent(input: SetComponentInput): SageEvent {
  return {
    type: 'panel:component',
    data: {
      componentId: input.componentId,
      value: input.value,
      confirmed: input.confirmed ?? true,
    },
  };
}

// =============================================================================
// Pending Events Queue
// =============================================================================

/**
 * Events generated by attuning tool handlers.
 *
 * The chat route collects these after tool dispatch and sends them as SSE.
 */
let pendingEvents: SageEvent[] = [];

/**
 * Get and clear all pending attuning events.
 */
export function drainAttuningEvents(): SageEvent[] {
  const events = [...pendingEvents];
  pendingEvents = [];
  return events;
}

// =============================================================================
// Tool Handlers
// =============================================================================

/**
 * Register all Attuning stage tool handlers.
 *
 * Called once at server startup to wire up the handlers.
 */
export function registerAttuningTools(): void {
  registerToolHandler('set_component', handleSetComponent);
}

/**
 * Handle the set_component tool call.
 *
 * Validates input, queues a panel:component event, and persists
 * the component selection to the adventure state.
 */
async function handleSetComponent(
  input: Record<string, unknown>
): Promise<{ result: unknown; isError: boolean }> {
  const componentInput = input as unknown as SetComponentInput;

  if (!isValidSetComponentInput(componentInput)) {
    return {
      result: 'componentId and value are required. Valid IDs: ' +
        VALID_COMPONENT_IDS.join(', '),
      isError: true,
    };
  }

  // Queue the panel:component event for the frontend
  pendingEvents.push(buildComponentEvent(componentInput));

  // Persist to Supabase (best effort)
  try {
    await persistComponentUpdate(componentInput);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error(`Failed to persist component: ${message}`);
  }

  return {
    result: {
      status: 'component_set',
      componentId: componentInput.componentId,
      value: componentInput.value,
      confirmed: componentInput.confirmed ?? true,
    },
    isError: false,
  };
}

// =============================================================================
// Validation
// =============================================================================

function isValidSetComponentInput(input: SetComponentInput): boolean {
  if (!input.componentId || !VALID_COMPONENT_IDS.includes(input.componentId)) {
    return false;
  }
  if (input.value === undefined || input.value === null) {
    return false;
  }
  return true;
}

// =============================================================================
// Persistence
// =============================================================================

/**
 * Persist the component update to the adventure state in Supabase.
 *
 * Best-effort; failures are logged but don't block the tool result.
 */
async function persistComponentUpdate(input: SetComponentInput): Promise<void> {
  const supabase = getSupabase();

  const { error } = await supabase.rpc('update_adventure_component', {
    p_component_id: input.componentId,
    p_value: input.value,
    p_confirmed: input.confirmed ?? true,
  });

  if (error) {
    // If the RPC doesn't exist yet, log but don't fail
    console.warn(`Component persistence RPC not available: ${error.message}`);
  }
}
